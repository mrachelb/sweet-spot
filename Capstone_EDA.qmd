---
title: "Capstone Project"
author: "Alex, Rachel, Vlatko, Malte"
date: "2024-06-06"
format: html
execute: 
  cache: true
  echo: false
  error: true
jupyter: python3
editor:
  render-on-save: true
---

# load libraries and data

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
d = pd.read_csv("data/daily_sales_report.csv")
```


# EDA 

```{python}
d.head()
```


```{python}
d["type_name"].value_counts()
```




# data cleaning

```{python}
d['date'] =pd.to_datetime(d['date'])
d['weekday'] =d['date'].dt.dayofweek
d.weekday.value_counts()
```


# Feature engeneering - Categorizing

```{python}
d.loc[d["type_name"] == "donuts", "item_name"].value_counts(normalize = True)
```


```{python}
d.loc[d["type_name"] == "donuts", "item_name"].value_counts()
```


```{python}


classics = [
    'Strawberry Sprinkles', 'White Choc & Strawberries', 'Choc Sprinkles', 
    'Cinnamon Sugar', 'Boston Cream', 'Classic Donut', 'Chocolate Peanut Fudge', 'Salted Caramel Hazelnut', 'Salted Caramel']

specials = [
    'Blueberry Lemon Cheesecake', 'Chocolate Bomboloni', 'Apple Pie', 
    'Bienenstich', 'Special Donut']
monthly_specials = [
    'Passionfruit', 'Strawberry Shortcake', 'Strawberries & Cream', 
    'Lemon Tart', 'Pistachio Dream']

different_products = ['Star Wars Day', 'Pizza Hawaii', 'Grilled Cheese', 'Pie Day', 'Bat', 'Cat Day', 'NYE: Tonka Cream', 'Zimtstern Donut', 'Free Donut Softeis ', 'Cookie Softie Sandwich', 'Choc Custard Filled', 'Free Donut Upgrade', 'Strawberry Bun', 'Fried Chicken & Donut Waffle', 'Waffle + Maple Syrup', 'Chicken Waffle Sriracha', 'Chicken Waffle Truffle', 'Waffle + Sriracha ', 'Chicken Waffle Maple', 'Grilled Cheese with JalapeÃ±os', 'Waffle + Truffle3', 'Grilled Cheese + Jalapenos', 'Classic Hot Dog', 'Special Hot Dog', 'Waffle + Truffle', 'Free Berliner', 'Letter Donuts']



# Function to determine the category
def categorize_item(item_name):
    if item_name in classics:
        return 'classics'
    elif item_name in specials:
        return 'specials'
    elif item_name in monthly_specials:
        return 'monthly_specials'
    elif item_name in different_products:
        return 'not_donut'
    elif item_name == 'donuts sold (old)':
        return 'old'
    elif item_name == 'Charity Donut':
        return 'charity_donut'
    else:
        return 'other'

# Apply the function to create the 'item_category' column
d['item_category'] = d['item_name'].apply(categorize_item)
```


```{python}
d["item_category"] = d.apply(lambda row: 'box' if row['type_name'] == 'box' else row['item_category'], axis=1)
```


```{python}
# Display the DataFrame
d.head(10)
```





# Feature engineering

## Adding weather variables


```{python}
from functions import transform_weather_temp, transform_weather_prec_sunshine
```


```{python}
prec = pd.read_csv("data/precipitation.txt", sep = ";")
sun = pd.read_csv("data/sunshine_hrs.txt", sep = ";")
temp = pd.read_csv("data/temp_humidity.txt", sep = ";")
```


```{python}
#renaming relevant column names 

prec = prec.rename(columns = {"  R1":"precipitation"})
sun = sun.rename(columns = {"SD_SO":"sunshine"})
temp = temp.rename(columns = {"TT_TU":"temp"})
```


```{python}
#apply weather transformation function --> from hourly to daily values 

prec = transform_weather_prec_sunshine(prec, "precipitation")
sun = transform_weather_prec_sunshine(sun, "sunshine")
```


```{python}
# converting sunshine in mins to sunshine in hours

sun["sunshine"] = sun["sunshine"]/60
```


```{python}
# apply weather transformation function for temp --> from hourly to daily values 

temp = transform_weather_temp(temp,"temp")
```


```{python}

# merged all weather datasets with. 

# Note !! Data for June 6 and June 7 was automatically removed through this merge

from functools import reduce
d = reduce(lambda left, right: pd.merge(left, right, on='date'), [d,prec,temp,sun])

```


# Visualizations

```{python}

# Plotting the bar chart
plt.figure(figsize=(14, 8))
sns.barplot(data=d, x='weekday', y='amount', hue='item_category')
plt.title('Total Amount per Weekday per Item Category (2017-2024)')
plt.xlabel('Weekday')
plt.ylabel('Total Amount')
plt.legend(title='Item Category', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.show()
```
# Categories balance
```{python}

import matplotlib.pyplot as plt

# Count occurrences of each item category
category_counts = d['item_category'].value_counts()

# Create bar plot
category_counts.plot(kind='bar', color='skyblue')

# Add labels and title
plt.title('Amount of Data per Item Category')
plt.xlabel('Item Category')
plt.ylabel('Count')

# Show plot
plt.show()
```

```{python}
# 1. Filter the DataFrame for 'other' in 'item_category'
filtered_d = d[d['item_category'] == 'other']

# 2. Extract the year and month from the 'date' column
filtered_d['year'] = filtered_d['date'].dt.year
filtered_d['month'] = filtered_d['date'].dt.month

# 3. Drop duplicate entries to get unique days per 'item_name', 'year', and 'month'
unique_days = filtered_d[['item_name', 'year', 'month', 'date', 'type_name']].drop_duplicates()

# 4. Group by 'item_name' and 'year' and count unique dates
unique_days_count = unique_days.groupby(['item_name', 'year', 'type_name']).size().reset_index(name='unique_days_count')

# 5. Aggregate the months in a comma-separated format
months_aggregated = unique_days.groupby(['item_name', 'year'])['month'].apply(lambda x: ','.join(map(str, sorted(x.unique())))).reset_index(name='months')


# 6. Merge the aggregated months back into the result DataFrame
result = pd.merge(unique_days_count, months_aggregated, on=['item_name', 'year'])

pd.set_option("display.max_rows", 305)
pd.set_option("display.large_repr", "truncate") 
result_df = pd.DataFrame(result)
result_df

```

```{python}
result['months_count'] = result['months'].apply(lambda x: len(x.split(',')))

# 8. Classify into bins
bins = ['3 or less', 'between 3 and 6', '6 or more']
result['bin'] = pd.cut(result['months_count'], bins=[0, 3, 6, float('inf')], labels=bins, right=False)

# 9. Count the number of rows in each bin
bin_counts = result['bin'].value_counts().reindex(bins)

# 10. Create the bar plot
bin_counts.plot(kind='bar', color='skyblue')

# Add labels and title
plt.title('Classifying types of product in "other"')
plt.xlabel('Number of Months')
plt.ylabel('Count')

# Show the plot
plt.show()
```

```{python}
filtered_result_not_seasonal = result_df
#if multiple year AND at least 6 months each year
#elif one year for 10 motns or more
#(dont know where to add, could be classics or specials. maybe keep them in others)

#everything else seasonal (add to montly_specials)

```

